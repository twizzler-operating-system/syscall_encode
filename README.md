
# Syscall Encode

So, the way we do function calls is pretty nice. In Rust, roughly,

```{rust}
fn some_functionality(some_arg: ArgType, ...) -> ReturnType...;
```

System calls, on the other hand, don't look like this. They are usually structured more like stuffing a bunch
of things into some registers and then issuing a "jumpy" instruction. Of course, under the hood, normal function
calls are "no different", but the thing is that the language doesn't provide a nice abstraction for syscalls like it
does for normal functions.

Instead we rely on the standard library, which may rely on libc, or other crates, to issue syscalls, partially because they
are such a pain to write. Fortunately most people are writing code for, like, a real operating system that has real libraries. But... what if we are the ones writing the operating system? Wouldn't it be nice if we had a simple way to define syscall arguments, auto-encode them into registers, derive the syscall table semi-automatically, and just get away from the annoying tedium of manually going around implementing syscall types.

That's this crate.

A syscall is, instead, a collection of things:

 - A type that defines the arguments.
 - A type that defines the errors.
 - A type that defines the success return values.
 - A number.
 - A kernel side receiver.

That syscall can then be issued against some ABI that implements the SyscallAbi trait. On the kernel side, we define
a handler that catches incoming syscalls and passes them to the code generated by the syscall_api macro.

There are two advantages to defining syscalls in terms of _types_ instead of _functions_. The first is that we can
use the type system of a competent language to constrain the behavior and use of a syscall type, and [that happens to be the other reason also](https://youtube.com/clip/UgkxPApxAt_SzXN5PcQSy8E271kn3sxtnSBx). 

For example, a common pattern in Rust is to ensure that your code is correct by construction. In this case, by limiting how a struct can even be created, you limit your API consumers' ability to do the Wrong Thing. If we have a syscall, Foo, which can only be created as a result of calling syscall Bar, we have just ensured that (without unsafe) the user cannot issue a call to Foo without first calling Bar. Now, of course the kernel needs to be a little more careful than just blindly assuming that. But it helps userspace code avoid some classes of bugs.